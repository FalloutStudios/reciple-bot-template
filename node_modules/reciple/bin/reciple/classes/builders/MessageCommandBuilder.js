"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageCommandBuilder = void 0;
const MessageCommandOptionBuilder_1 = require("./MessageCommandOptionBuilder");
class MessageCommandBuilder {
    constructor() {
        this.builder = 'MESSAGE_COMMAND';
        this.name = '';
        this.cooldown = 0;
        this.description = '';
        this.aliases = [];
        this.options = [];
        this.validateOptions = false;
        this.requiredBotPermissions = [];
        this.RequiredUserPermissions = [];
        this.allowExecuteInDM = true;
        this.allowExecuteByBots = false;
        this.execute = () => { };
    }
    /**
     * Sets the command name
     */
    setName(name) {
        if (!name || typeof name !== 'string' || !name.match(/^[\w-]{1,32}$/))
            throw new TypeError('name must be a string and match the regex /^[\\w-]{1,32}$/');
        this.name = name;
        return this;
    }
    /**
     * Sets the command description
     */
    setDescription(description) {
        if (!description || typeof description !== 'string')
            throw new TypeError('description must be a string.');
        this.description = description;
        return this;
    }
    /**
     * Sets the execute cooldown for this command.
     * - `0` means no cooldown
     */
    setCooldown(cooldown) {
        this.cooldown = cooldown;
        return this;
    }
    /**
     * Add aliases to the command
     */
    addAliases(...aliases) {
        if (!aliases.length)
            throw new TypeError('Provide atleast one alias');
        if (aliases.some(a => !a || typeof a !== 'string' || !a.match(/^[\w-]{1,32}$/)))
            throw new TypeError('aliases must be strings and match the regex /^[\\w-]{1,32}$/');
        if (this.name && aliases.some(a => a == this.name))
            throw new TypeError('alias cannot have same name to its real command name');
        this.aliases = [...new Set(aliases)];
        return this;
    }
    /**
     * Set required per
     */
    setRequiredBotPermissions(...permissions) {
        this.requiredBotPermissions = permissions;
        return this;
    }
    /**
     * Set required user permissions to execute the command
     */
    setRequiredMemberPermissions(...permissions) {
        this.RequiredUserPermissions = permissions;
        return this;
    }
    /**
     * Set if command can be executed in dms
     */
    setAllowExecuteInDM(allowExecuteInDM) {
        if (typeof allowExecuteInDM !== 'boolean')
            throw new TypeError('allowExecuteInDM must be a boolean.');
        this.allowExecuteInDM = allowExecuteInDM;
        return this;
    }
    /**
     * Allow command to be executed by bots
     */
    setAllowExecuteByBots(allowExecuteByBots) {
        if (typeof allowExecuteByBots !== 'boolean')
            throw new TypeError('allowExecuteByBots must be a boolean.');
        this.allowExecuteByBots = allowExecuteByBots;
        return this;
    }
    /**
     * Function when the command is interupted before execution
     */
    setHalt(halt) {
        this.halt = halt ? halt : undefined;
        return this;
    }
    /**
     * Function when the command is executed
     */
    setExecute(execute) {
        if (!execute || typeof execute !== 'function')
            throw new TypeError('execute must be a function.');
        this.execute = execute;
        return this;
    }
    /**
     * Add option to the command
     */
    addOption(option) {
        if (!option)
            throw new TypeError('option must be a MessageOption.');
        option = typeof option === 'function' ? option(new MessageCommandOptionBuilder_1.MessageCommandOptionBuilder()) : option;
        if (this.options.find(o => o.name === option.name))
            throw new TypeError('option with name "' + option.name + '" already exists.');
        if (this.options.length > 0 && !this.options[this.options.length - 1 < 0 ? 0 : this.options.length - 1].required && option.required)
            throw new TypeError('All required options must be before optional options.');
        this.options = [...this.options, option];
        return this;
    }
    /**
     * Validate options before executing
     */
    setValidateOptions(validateOptions) {
        if (typeof validateOptions !== 'boolean')
            throw new TypeError('validateOptions must be a boolean.');
        this.validateOptions = validateOptions;
        return this;
    }
    /**
     * validate given command options
     */
    getCommandOptionValues(options) {
        const args = options.args || [];
        const required = this.options.filter(o => o.required);
        const optional = this.options.filter(o => !o.required);
        const allOptions = [...required, ...optional];
        const result = [];
        let i = 0;
        for (const option of allOptions) {
            const arg = args[i];
            const value = {
                name: option.name,
                value: arg !== null && arg !== void 0 ? arg : undefined,
                required: option.required,
                invalid: false,
                missing: false
            };
            if (arg == undefined && option.required) {
                value.missing = true;
                result.push(value);
                continue;
            }
            if (arg == undefined && !option.required) {
                result.push(value);
                continue;
            }
            const validate = option.validator ? option.validator(arg) : true;
            if (!validate)
                value.invalid = true;
            result.push(value);
            i++;
        }
        return result;
    }
}
exports.MessageCommandBuilder = MessageCommandBuilder;
