"use strict";
// Not cool code
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RecipleClient = void 0;
const registerInteractionCommands_1 = require("../registerInteractionCommands");
const permissions_1 = require("../permissions");
const CommandCooldownManager_1 = require("./CommandCooldownManager");
const MessageCommandOptionManager_1 = require("./MessageCommandOptionManager");
const modules_1 = require("../modules");
const fallout_utility_1 = require("fallout-utility");
const RecipleConfig_1 = require("./RecipleConfig");
const isIgnoredChannel_1 = require("../isIgnoredChannel");
const version_1 = require("../version");
const logger_1 = require("../logger");
const discord_js_1 = require("discord.js");
class RecipleClient extends discord_js_1.Client {
    constructor(options) {
        var _a, _b, _c;
        super(options);
        this.config = RecipleConfig_1.RecipleConfig.getDefaultConfig();
        this.commands = { MESSAGE_COMMANDS: {}, INTERACTION_COMMANDS: {} };
        this.otherApplicationCommandData = [];
        this.commandCooldowns = new CommandCooldownManager_1.CommandCooldownManager();
        this.modules = [];
        this.version = version_1.version;
        this.logger = (0, logger_1.logger)(!!((_a = options.config) === null || _a === void 0 ? void 0 : _a.fileLogging.stringifyLoggedJSON), !!((_b = options.config) === null || _b === void 0 ? void 0 : _b.fileLogging.debugmode));
        if (!options.config)
            throw new Error('Config is not defined.');
        this.config = Object.assign(Object.assign({}, this.config), ((_c = options.config) !== null && _c !== void 0 ? _c : {}));
        if (this.config.fileLogging.enabled)
            this.logger.logFile(this.config.fileLogging.logFilePath, false);
    }
    /**
     * Load modules
     */
    startModules(folder) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isClientLogsEnabled())
                this.logger.info(`Loading Modules from ${folder !== null && folder !== void 0 ? folder : this.config.modulesFolder}`);
            const modules = yield (0, modules_1.loadModules)(this, folder);
            if (!modules)
                throw new Error('Failed to load modules.');
            this.modules = modules.modules;
            return this;
        });
    }
    /**
     * Execute `onLoad()` from client modules and register interaction commands if enabled
     */
    loadModules() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            for (const m in this.modules) {
                const module_ = this.modules[m];
                if (typeof ((_a = module_.script) === null || _a === void 0 ? void 0 : _a.onLoad) === 'function') {
                    yield Promise.resolve(module_.script.onLoad(this)).catch(err => {
                        var _a;
                        if (this.isClientLogsEnabled()) {
                            this.logger.error(`Error loading ${(_a = module_.info.filename) !== null && _a !== void 0 ? _a : 'unknown module'}:`);
                            this.logger.error(err);
                        }
                        this.modules = this.modules.filter((_r, i) => i.toString() !== m.toString());
                    });
                }
                if (typeof ((_b = module_.script) === null || _b === void 0 ? void 0 : _b.commands) !== 'undefined') {
                    for (const command of module_.script.commands) {
                        this.addCommand(command);
                    }
                }
            }
            if (this.isClientLogsEnabled()) {
                this.logger.info(`${this.modules.length} modules loaded.`);
                this.logger.info(`${Object.keys(this.commands.MESSAGE_COMMANDS).length} message commands loaded.`);
                this.logger.info(`${Object.keys(this.commands.INTERACTION_COMMANDS).length} interaction commands loaded.`);
            }
            if (this.config.commands.interactionCommand.registerCommands) {
                yield (0, registerInteractionCommands_1.registerInteractionCommands)(this, [...Object.values(this.commands.INTERACTION_COMMANDS), ...this.otherApplicationCommandData]);
            }
            return this;
        });
    }
    /**
     * Add module
     */
    addModule(script, registerCommands = true, info) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            this.modules.push({
                script,
                info: Object.assign({ filename: undefined, versions: typeof script.versions == 'string' ? [script.versions] : script.versions, path: undefined }, info)
            });
            if (typeof (script === null || script === void 0 ? void 0 : script.onLoad) === 'function')
                yield Promise.resolve(script.onLoad(this));
            if (this.isClientLogsEnabled())
                this.logger.info(`${this.modules.length} modules loaded.`);
            for (const command of (_a = script.commands) !== null && _a !== void 0 ? _a : []) {
                if (!command.name)
                    continue;
                this.addCommand(command);
            }
            if (!registerCommands || !this.config.commands.interactionCommand.registerCommands)
                return;
            yield (0, registerInteractionCommands_1.registerInteractionCommands)(this, [...Object.values(this.commands.INTERACTION_COMMANDS), ...this.otherApplicationCommandData]);
        });
    }
    /**
     * Add interaction or message command to client
     */
    addCommand(command) {
        var _a;
        if (command.builder === 'MESSAGE_COMMAND') {
            this.commands.MESSAGE_COMMANDS[command.name] = command;
        }
        else if (command.builder === 'INTERACTION_COMMAND') {
            this.commands.INTERACTION_COMMANDS[command.name] = command;
        }
        else if (this.isClientLogsEnabled()) {
            this.logger.error(`Unknow command "${(_a = typeof command) !== null && _a !== void 0 ? _a : 'unknown'}".`);
        }
        return this;
    }
    /**
     * Listed to command executions
     */
    addCommandListeners() {
        if (this.config.commands.messageCommand.enabled)
            this.on('messageCreate', (message) => { this.messageCommandExecute(message); });
        if (this.config.commands.interactionCommand.enabled)
            this.on('interactionCreate', (interaction) => { this.interactionCommandExecute(interaction); });
        return this;
    }
    /**
     * Execute a Message command
     */
    messageCommandExecute(message, prefix) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!message.content || !this.isReady())
                return;
            const parseCommand = (0, fallout_utility_1.getCommand)(message.content, prefix || this.config.prefix || '!', this.config.commands.messageCommand.commandArgumentSeparator || ' ');
            if (!parseCommand || !(parseCommand === null || parseCommand === void 0 ? void 0 : parseCommand.command))
                return;
            const command = this.findCommand(parseCommand.command, 'MESSAGE_COMMAND');
            if (!command)
                return;
            const commandOptions = command.getCommandOptionValues(parseCommand);
            const executeData = {
                message: message,
                options: new MessageCommandOptionManager_1.MessageCommandOptionManager(commandOptions),
                command: parseCommand,
                builder: command,
                client: this
            };
            if ((0, permissions_1.userHasCommandPermissions)(command.name, (_a = message.member) === null || _a === void 0 ? void 0 : _a.permissions, this.config.permissions.messageCommands, command)) {
                if (!command.allowExecuteInDM && message.channel.type === 'DM'
                    || !command.allowExecuteByBots
                        && (message.author.bot || message.author.system)
                    || (0, isIgnoredChannel_1.isIgnoredChannel)(message.channelId, this.config.ignoredChannels))
                    return;
                if (command.validateOptions) {
                    if (commandOptions.some(o => o.invalid)) {
                        if (!(command === null || command === void 0 ? void 0 : command.halt) || !(yield command.halt({ executeData, reason: 'INVALID_ARGUMENTS', invalidArguments: new MessageCommandOptionManager_1.MessageCommandOptionManager(executeData.options.filter(o => o.invalid)) }))) {
                            message.reply(this.getMessage('invalidArguments', 'Invalid argument(s) given.')).catch(er => this._replyError(er));
                        }
                        return;
                    }
                    if (commandOptions.some(o => o.missing)) {
                        if (!command.halt || !(yield command.halt({ executeData, reason: 'MISSING_ARGUMENTS', missingArguments: new MessageCommandOptionManager_1.MessageCommandOptionManager(executeData.options.filter(o => o.missing)) }))) {
                            message.reply(this.getMessage('notEnoughArguments', 'Not enough arguments.')).catch(er => this._replyError(er));
                        }
                        return;
                    }
                }
                if (message.guild && !(0, permissions_1.botHasExecutePermissions)(message.guild, command.requiredBotPermissions)) {
                    if (!command.halt || !(yield command.halt({ executeData, reason: 'MISSING_BOT_PERMISSIONS' }))) {
                        message.reply(this.getMessage('insufficientBotPerms', 'Insufficient bot permissions.')).catch(er => this._replyError(er));
                    }
                    return;
                }
                const userCooldown = {
                    user: message.author,
                    command: command.name,
                    channel: message.channel,
                    guild: message.guild,
                    type: 'MESSAGE_COMMAND'
                };
                if (this.config.commands.messageCommand.enableCooldown && command.cooldown && !this.commandCooldowns.isCooledDown(userCooldown)) {
                    this.commandCooldowns.add(Object.assign(Object.assign({}, userCooldown), { expireTime: Date.now() + command.cooldown }));
                }
                else if (this.config.commands.messageCommand.enableCooldown && command.cooldown) {
                    if (!command.halt || !(yield command.halt(Object.assign({ executeData, reason: 'COOLDOWN' }, this.commandCooldowns.get(userCooldown))))) {
                        yield message.reply(this.getMessage('cooldown', 'You cannot execute this command right now due to the cooldown.')).catch(er => this._replyError(er));
                    }
                    return;
                }
                try {
                    yield Promise.resolve(command.execute(executeData)).catch((err) => __awaiter(this, void 0, void 0, function* () { return !command.halt || !(yield command.halt({ executeData, reason: 'ERROR', error: err })) ? this._commandExecuteError(err, executeData) : void 0; }));
                    this.emit('recipleMessageCommandCreate', executeData);
                    return executeData;
                }
                catch (err) {
                    if (!command.halt || !(yield command.halt({ executeData, reason: 'ERROR', error: err }))) {
                        this._commandExecuteError(err, executeData);
                    }
                }
            }
            else if (!command.halt || !(yield command.halt({ executeData, reason: 'MISSING_MEMBER_PERMISSIONS' }))) {
                message.reply(this.getMessage('noPermissions', 'You do not have permission to use this command.')).catch(er => this._replyError(er));
            }
        });
    }
    /**
     * Execute an Interaction command
     */
    interactionCommandExecute(interaction) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (!interaction || !interaction.isCommand() || !this.isReady())
                return;
            const command = this.findCommand(interaction.commandName, 'INTERACTION_COMMAND');
            if (!command)
                return;
            const executeData = {
                interaction: interaction,
                builder: command,
                client: this
            };
            if ((0, permissions_1.userHasCommandPermissions)(command.name, (_a = interaction.memberPermissions) !== null && _a !== void 0 ? _a : undefined, this.config.permissions.interactionCommands, command)) {
                if (!command || (0, isIgnoredChannel_1.isIgnoredChannel)(interaction.channelId, this.config.ignoredChannels))
                    return;
                if (interaction.guild && !(0, permissions_1.botHasExecutePermissions)(interaction.guild, command.requiredBotPermissions)) {
                    if (!command.halt || !(yield command.halt({ executeData, reason: 'MISSING_BOT_PERMISSIONS' }))) {
                        yield interaction.reply(this.getMessage('insufficientBotPerms', 'Insufficient bot permissions.')).catch(er => this._replyError(er));
                    }
                    return;
                }
                const userCooldown = {
                    user: interaction.user,
                    command: command.name,
                    channel: (_b = interaction.channel) !== null && _b !== void 0 ? _b : undefined,
                    guild: interaction.guild,
                    type: 'INTERACTION_COMMAND'
                };
                if (this.config.commands.interactionCommand.enableCooldown && command.cooldown && !this.commandCooldowns.isCooledDown(userCooldown)) {
                    this.commandCooldowns.add(Object.assign(Object.assign({}, userCooldown), { expireTime: Date.now() + command.cooldown }));
                }
                else if (this.config.commands.interactionCommand.enableCooldown && command.cooldown) {
                    if (!command.halt || !(yield command.halt(Object.assign({ executeData, reason: 'COOLDOWN' }, this.commandCooldowns.get(userCooldown))))) {
                        yield interaction.reply(this.getMessage('cooldown', 'You cannot execute this command right now due to the cooldown.')).catch(er => this._replyError(er));
                    }
                    return;
                }
                try {
                    yield Promise.resolve(command.execute(executeData)).catch((err) => __awaiter(this, void 0, void 0, function* () { return !command.halt || !(yield command.halt({ executeData, reason: 'ERROR', error: err })) ? this._commandExecuteError(err, executeData) : void 0; }));
                    this.emit('recipleInteractionCommandCreate', executeData);
                    return executeData;
                }
                catch (err) {
                    if (!command.halt || !(yield command.halt({ executeData, reason: 'ERROR', error: err }))) {
                        this._commandExecuteError(err, executeData);
                    }
                }
            }
            else if (!command.halt || !(yield command.halt({ executeData, reason: 'MISSING_MEMBER_PERMISSIONS' }))) {
                yield interaction.reply(this.getMessage('noPermissions', 'You do not have permission to use this command.')).catch(er => this._replyError(er));
            }
        });
    }
    /**
     * Get a message from config
     */
    getMessage(messageKey, defaultMessage) {
        var _a, _b;
        return (_b = (_a = this.config.messages[messageKey]) !== null && _a !== void 0 ? _a : defaultMessage) !== null && _b !== void 0 ? _b : messageKey;
    }
    findCommand(command, type) {
        var _a;
        switch (type) {
            case 'INTERACTION_COMMAND':
                return this.commands.INTERACTION_COMMANDS[command];
            case 'MESSAGE_COMMAND':
                return (_a = this.commands.MESSAGE_COMMANDS[command.toLowerCase()]) !== null && _a !== void 0 ? _a : (this.config.commands.messageCommand.allowCommandAlias
                    ? Object.values(this.commands.MESSAGE_COMMANDS).find(c => c.aliases.some(a => a == (command === null || command === void 0 ? void 0 : command.toLowerCase())))
                    : undefined);
            default:
                throw new TypeError('Unknown command type');
        }
    }
    /**
     * Returns true if client logs is enabled
     */
    isClientLogsEnabled() {
        return !!this.config.fileLogging.clientLogs;
    }
    /**
     * Emits the "recipleReplyError" event
     */
    _replyError(error) {
        this.emit('recipleReplyError', error);
    }
    /**
     * Error message when a command fails to execute
     */
    _commandExecuteError(err, command) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isClientLogsEnabled()) {
                this.logger.error(`An error occured executing ${command.builder.builder == 'MESSAGE_COMMAND' ? 'message' : 'interaction'} command "${command.builder.name}"`);
                this.logger.error(err);
            }
            if (!err || !command)
                return;
            if (command === null || command === void 0 ? void 0 : command.message) {
                if (!this.config.commands.messageCommand.replyOnError)
                    return;
                yield command.message.reply(this.getMessage('error', 'An error occurred.')).catch(er => this._replyError(er));
            }
            else if (command === null || command === void 0 ? void 0 : command.interaction) {
                if (!this.config.commands.interactionCommand.replyOnError)
                    return;
                yield command.interaction.followUp(this.getMessage('error', 'An error occurred.')).catch(er => this._replyError(er));
            }
        });
    }
}
exports.RecipleClient = RecipleClient;
