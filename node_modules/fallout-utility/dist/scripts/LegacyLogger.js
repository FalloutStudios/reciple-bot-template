"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Logger = void 0;
const chalk_1 = __importDefault(require("chalk"));
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const replaceAll_1 = require("./replaceAll");
const inspector_1 = __importDefault(require("inspector"));
class Logger {
    constructor(defaultPrefix, options) {
        this.options = {
            stringifyJSON: false,
            writeStream: undefined,
            setDebugging: undefined,
            colorizeStringLog: true,
            prefix: {
                enabled: true,
                startBracket: '[',
                endBracket: ']',
                separator: ' - ',
                levels: ['INFO', 'WARN', 'ERROR', 'DEBUG']
            },
        };
        this.debugging = false;
        this.options = options || this.options;
        this.defaultPrefix = defaultPrefix;
        this.writeStream = (options === null || options === void 0 ? void 0 : options.writeStream) || undefined;
        this.debugging = options && (options === null || options === void 0 ? void 0 : options.setDebugging) !== undefined ? options === null || options === void 0 ? void 0 : options.setDebugging : Logger.isDebugging();
    }
    /**
     *
     * Log to file
     */
    logFile(logFilePath, overwriteOldFile = false) {
        if (!logFilePath)
            throw new TypeError("Log file path is not defined");
        const dir = path.dirname(logFilePath);
        const file = path.basename(logFilePath);
        const header = `[LOG HEADER] ${(0, replaceAll_1.replaceAll)(new Date().toJSON(), ':', '-')}\n[LOG] Original file: ${file}\n[LOG] Original path: ${dir}\n`;
        let overwriten = false;
        if (fs.existsSync(logFilePath)) {
            if (!overwriteOldFile) {
                const fileInfo = path.parse(file);
                const headerInfo = this.parseLogHeader(fs.readFileSync(logFilePath, 'utf8')).map(line => line.replace('[LOG HEADER] ', ''));
                fs.renameSync(logFilePath, path.join(dir, `${headerInfo[0] || (0, replaceAll_1.replaceAll)(new Date().toJSON(), ':', '-') + '-1'}${fileInfo.ext}`));
                overwriten = true;
            }
        }
        else {
            fs.mkdirSync(dir, { recursive: true });
            overwriten = true;
        }
        this.writeStream = fs.createWriteStream(logFilePath);
        if (overwriten)
            this.writeStream.write(header);
        return this;
    }
    /**
     *
     * Sets the current write stream
     */
    setWriteStream(writeStream) {
        this.writeStream = writeStream;
        return this;
    }
    /**
     *
     * Creates new logger
     */
    cloneLogger() {
        const logger = new Logger(this.defaultPrefix, this.options);
        logger.writeStream = this.writeStream;
        logger.debugging = this.debugging;
        return logger;
    }
    setDebugging(debugging) {
        this.debugging = !!debugging;
        return this;
    }
    /**
     *
     * Remove write stream
     */
    stopLogWriteStream() {
        if (!this.writeStream)
            return this;
        this.writeStream.end();
        this.writeStream = undefined;
        return this;
    }
    parseLogHeader(log) {
        return log.split('\n').filter(line => line.startsWith('[LOG HEADER]'));
    }
    /**
     *
     * Print message to console
     */
    log(args, setPrefix = this.defaultPrefix) { return this.parseLogMessage(args, setPrefix, 0); }
    /**
     *
     * Print message to console
     */
    info(args, setPrefix = this.defaultPrefix) { return this.parseLogMessage(args, setPrefix, 0); }
    /**
     *
     * Print warn message to console
     */
    warn(args, setPrefix = this.defaultPrefix) { return this.parseLogMessage(args, setPrefix, 1); }
    /**
     *
     * Print error message to console
     */
    error(args, setPrefix = this.defaultPrefix) { return this.parseLogMessage(args, setPrefix, 2); }
    /**
     *
     * Print a debug message to console only if the debug mode is enabled
     */
    debug(args, setPrefix = this.defaultPrefix) { return this.debugging ? this.parseLogMessage(args, setPrefix, 3) : undefined; }
    parseLogMessage(message, setPrefix = this.defaultPrefix, level = 0) {
        if (typeof message === 'string') {
            message = message.split('\n');
            for (let value of message) {
                this.writeLog(value, setPrefix, level);
            }
            return;
        }
        this.writeLog(message, setPrefix, level);
    }
    writeLog(message, prefix = this.defaultPrefix, level = 0) {
        var _a;
        const consolePrefix = this.getPrefix(prefix, level);
        const consolePrefixText = this.getPrefix(prefix, level, false);
        if (typeof message === 'string' || typeof message === 'number') {
            Logger.print(level, consolePrefix, this.options.colorizeStringLog || this.options.colorizeStringLog === undefined ? this.colorize(`${message}`, level) : `${message}`);
            this.writeToStream(`${message}`, consolePrefixText);
        }
        else if (message instanceof Error) {
            Logger.print(level, consolePrefix, message);
            const stack = (_a = message.stack) === null || _a === void 0 ? void 0 : _a.split('\n');
            if (!stack)
                return;
            if (this.options.addPrefixToEveryJsonNewLines) {
                stack.forEach(line => this.writeToStream(line, consolePrefixText));
            }
            else {
                this.writeToStream(`\n${stack.join('\n')}`, consolePrefixText);
            }
        }
        else if (typeof message === 'object' && this.options.stringifyJSON) {
            this.parseLogMessage(JSON.stringify(message, null, 2), prefix, level);
            return;
        }
        else if (typeof message === 'object') {
            Logger.print(level, consolePrefix);
            Logger.print(level, message);
            const json = JSON.stringify(message, null, 2);
            if (this.options.addPrefixToEveryJsonNewLines) {
                json.split('\n').forEach(line => this.writeToStream(line, consolePrefixText));
            }
            else {
                this.writeToStream(`\n${json}`, consolePrefixText);
            }
        }
        else {
            Logger.print(level, consolePrefix);
            Logger.print(level, message);
            this.writeToStream(message, consolePrefixText);
        }
    }
    getPrefix(prefix, level = 0, colors = true) {
        var _a, _b, _c, _d, _e, _f;
        if (((_a = this.options.prefix) === null || _a === void 0 ? void 0 : _a.enabled) === false)
            return '';
        const levelPrefix = ((_b = this.options.prefix) === null || _b === void 0 ? void 0 : _b.levels[level]) || (['INFO', 'WARN', 'ERROR', 'DEBUG'])[level];
        const logPrefix = colors ? chalk_1.default.bold(this.colorize(levelPrefix, level)) : levelPrefix;
        const separator = colors ? chalk_1.default.gray(((_c = this.options.prefix) === null || _c === void 0 ? void 0 : _c.separator) || ' - ') : ((_d = this.options.prefix) === null || _d === void 0 ? void 0 : _d.separator) || ' - ';
        const mainPrefix = colors ? chalk_1.default.bold(this.colorize(prefix !== null && prefix !== void 0 ? prefix : '', level)) : prefix !== null && prefix !== void 0 ? prefix : '';
        const brackets = [
            ((_e = this.options.prefix) === null || _e === void 0 ? void 0 : _e.startBracket) || '[',
            ((_f = this.options.prefix) === null || _f === void 0 ? void 0 : _f.endBracket) || ']'
        ];
        return `${brackets[0]}${logPrefix}${separator}${mainPrefix}${brackets[1]}`;
    }
    writeToStream(message, prefix) {
        if (!this.writeStream)
            return this;
        this.writeStream.write(`${prefix} ${message.toString().trimEnd()}\n`, 'utf-8');
        return this;
    }
    colorize(string, level) {
        switch (level) {
            case 0: return string;
            case 1: return chalk_1.default.yellow(string);
            case 2: return chalk_1.default.red(string);
            case 3: return chalk_1.default.blue(string);
        }
    }
    static isDebugging() {
        return !!inspector_1.default.url() || /--debug|--inspect/g.test(process.execArgv.join(''));
    }
    static print(level, ...args) {
        switch (level) {
            case 0:
                console.log(...args);
                break;
            case 1:
                console.warn(...args);
                break;
            case 2:
                console.error(...args);
                break;
            case 3:
                console.debug(...args);
                break;
        }
    }
}
exports.Logger = Logger;
