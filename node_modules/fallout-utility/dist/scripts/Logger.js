"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Logger = exports.LogLevels = void 0;
const fs = __importStar(require("fs"));
const chalk_1 = __importDefault(require("chalk"));
const path = __importStar(require("path"));
const inspector_1 = __importDefault(require("inspector"));
const trimChar_1 = require("./trimChar");
const isNumber_1 = require("./isNumber");
const strip_ansi_1 = __importDefault(require("strip-ansi"));
var LogLevels;
(function (LogLevels) {
    LogLevels[LogLevels["INFO"] = 0] = "INFO";
    LogLevels[LogLevels["WARN"] = 1] = "WARN";
    LogLevels[LogLevels["ERROR"] = 2] = "ERROR";
    LogLevels[LogLevels["DEBUG"] = 3] = "DEBUG";
})(LogLevels = exports.LogLevels || (exports.LogLevels = {}));
class Logger {
    constructor(options) {
        var _a, _b, _c;
        this.options = {
            enableDebugMode: Logger.isDebugging(),
            addPrefixToAllNewLines: true,
            prefixes: {
                [LogLevels.INFO]: (loggerName) => chalk_1.default.bold(loggerName ? `${chalk_1.default.dim(loggerName)}${chalk_1.default.gray('/')}${'INFO'}` : 'INFO') + ' ',
                [LogLevels.WARN]: (loggerName) => chalk_1.default.bold(loggerName ? `${chalk_1.default.yellow.dim(loggerName)}${chalk_1.default.gray('/')}${chalk_1.default.yellow('WARN')}` : 'WARN') + ' ',
                [LogLevels.ERROR]: (loggerName) => chalk_1.default.bold(loggerName ? `${chalk_1.default.red.dim(loggerName)}${chalk_1.default.gray('/')}${chalk_1.default.red('ERROR')}` : 'ERROR') + ' ',
                [LogLevels.DEBUG]: (loggerName) => chalk_1.default.bold(loggerName ? `${chalk_1.default.magenta.dim(loggerName)}${chalk_1.default.gray('/')}${chalk_1.default.magenta('DEBUG')}` : 'DEBUG' + ' ')
            },
            colorMessages: {
                [LogLevels.INFO]: (message) => message,
                [LogLevels.WARN]: (message) => message,
                [LogLevels.ERROR]: (message) => message,
                [LogLevels.DEBUG]: (message) => message
            },
            stringifyJSON: true,
        };
        this.enableDebugMode = false;
        this.options = options ? Object.assign(Object.assign({}, this.options), options) : this.options;
        this.loggerName = (_a = options === null || options === void 0 ? void 0 : options.loggerName) !== null && _a !== void 0 ? _a : undefined;
        this.writeStream = (_b = options === null || options === void 0 ? void 0 : options.writeStream) !== null && _b !== void 0 ? _b : undefined;
        this.enableDebugMode = (_c = options === null || options === void 0 ? void 0 : options.enableDebugMode) !== null && _c !== void 0 ? _c : false;
    }
    // Aliases
    info(...message) { this.log(...message); }
    err(...message) { this.error(...message); }
    log(...message) { this.parseLogMessage(message, LogLevels.INFO); }
    warn(...message) { this.parseLogMessage(message, LogLevels.WARN); }
    error(...message) { this.parseLogMessage(message, LogLevels.ERROR); }
    debug(...message) { if (this.enableDebugMode)
        this.parseLogMessage(message, LogLevels.DEBUG); }
    cloneLogger(options) {
        const logger = new Logger(Object.assign(Object.assign(Object.assign({}, this.options), { loggerName: this.loggerName }), (options !== null && options !== void 0 ? options : {})));
        logger.writeStream = (options === null || options === void 0 ? void 0 : options.writeStream) || this.writeStream;
        logger.enableDebugMode = (options === null || options === void 0 ? void 0 : options.enableDebugMode) || this.enableDebugMode;
        return logger;
    }
    logFile(fileName, overwriteOldFile = false) {
        var _a;
        if (!fileName)
            throw new TypeError("Log file path is not defined");
        const dir = path.dirname(fileName);
        const file = path.basename(fileName);
        let writeHeader = false;
        fs.mkdirSync(dir, { recursive: true });
        if (fs.existsSync(fileName) && !overwriteOldFile) {
            const header = this.parseLogHeader(fileName);
            if (header) {
                const date = `${header.date.toDateString()} - ${header.date.getHours()}-${header.date.getMinutes()}-${header.date.getSeconds()}-${header.date.getMilliseconds()}`;
                fs.renameSync(fileName, path.join(dir, `${date}${(_a = path.extname(file)) !== null && _a !== void 0 ? _a : '.log'}`));
            }
            else {
                fs.rmSync(fileName, { recursive: true, force: true });
            }
            writeHeader = true;
        }
        this.writeStream = fs.createWriteStream(fileName);
        if (writeHeader)
            this.writeStream.write(this.createLogHeader(file));
        return this;
    }
    setWriteStream(writeStream) {
        this.writeStream = writeStream;
    }
    stopLogWriteStream() {
        if (!this.writeStream || this.writeStream.destroyed)
            return;
        this.writeStream.end();
        this.writeStream = undefined;
    }
    setEnableDebugMode(enable) {
        this.enableDebugMode = !!enable;
    }
    parseLogHeader(file) {
        var _a, _b;
        if (!file)
            throw new TypeError('file is not defined');
        if (!fs.existsSync(file))
            throw new TypeError('file does not exists');
        let log = fs.readFileSync(file, 'utf-8');
        log = (_a = log.split(`=`.repeat(20))[0]) !== null && _a !== void 0 ? _a : '';
        if (!log)
            return undefined;
        log = log.split('\n');
        const time = (log[0].startsWith(`Time: `) ? (0, trimChar_1.trimChars)(log[0], `Time: `) : null);
        const originalFile = (_b = (log[0].startsWith(`File: `) ? (0, trimChar_1.trimChars)(log[0], `File: `) : null)) !== null && _b !== void 0 ? _b : file;
        return {
            date: new Date((0, isNumber_1.isNumber)(Number(time)) ? Number(time) : Date.now() - 1),
            file: originalFile
        };
    }
    createLogHeader(file) {
        if (!file)
            throw new TypeError('file is not defined');
        return `Time: ${new Date().getTime()}\n` +
            `File: ${file}\n` +
            `=`.repeat(20) +
            `\n`;
    }
    parseLogMessage(messages, level) {
        for (const message of messages) {
            if (typeof message == 'string') {
                for (const line of message.split('\n')) {
                    this.writeLog(line, level);
                }
                continue;
            }
            this.writeLog(message, level);
        }
    }
    writeLog(message, level) {
        if (['boolean', 'string', 'number', 'undefined'].includes(typeof message)) {
            return this.print(`${String(message)}`, level);
        }
        else if (message instanceof Error) {
            if (!message.stack)
                return this.print(`${message.name}: ${message.message}`, level);
            if (!this.options.addPrefixToAllNewLines)
                return this.print(`${message.stack}`, level);
            return this.parseLogMessage(message.stack.split('\n'), level);
        }
        else if (typeof message === 'object' && this.options.stringifyJSON) {
            return this.parseLogMessage(JSON.stringify(message, null, 2).split('\n'), level);
        }
        else if (typeof message === 'object') {
            this.print(message, level, false, true);
            this.print(`${JSON.stringify(message, null, 2)}`, level, true, false);
        }
        else if (typeof message === 'function') {
            this.print(`${message.toString()}`, level);
        }
        else {
            this.print(message, level, false);
        }
    }
    print(message, level = LogLevels.INFO, write = true, consoleLog = true) {
        let prefix = this.options.prefixes[level];
        prefix = (prefix ? prefix(this.loggerName) : '');
        let noColorPrefix = (0, strip_ansi_1.default)(prefix);
        if (consoleLog) {
            const colorize = this.options.colorMessages[level];
            switch (level) {
                case LogLevels.INFO:
                    console.log(prefix, colorize(message));
                    break;
                case LogLevels.WARN:
                    console.warn(prefix, colorize(message));
                    break;
                case LogLevels.ERROR:
                    console.error(prefix, colorize(message));
                    break;
                case LogLevels.DEBUG:
                    console.debug(prefix, colorize(message));
                    break;
            }
        }
        if (!this.writeStream || this.writeStream.destroyed || !write)
            return;
        this.writeStream.write(`${noColorPrefix ? noColorPrefix + ' ' : ''}${message.toString().trimEnd()}\n`, 'utf-8');
    }
    static isDebugging() {
        return !!inspector_1.default.url() || /--debug|--inspect/g.test(process.execArgv.join(''));
    }
}
exports.Logger = Logger;
